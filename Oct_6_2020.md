
<img src='./images/class_logo.png' width=500px align='right' style='padding-left:30px'>

**Week of October 5th, 2020**<br>  
**ATMOS 5340: Environmental Programming and Statistics**<br>
**John Horel and Derek Mallia**<br>
<br>

> # Announcement: 
> Your 4th programming assignement on Module 5 is **due this Sunday.**

> # Today's Objective<br>
> Opening/closing basic text files with Python<br>
> Reading in data and information from text and csv formatted files<br>
> Writing out text and csv-formatted files<br>
> Working with path and file names
<br><br>


#  Python File I/O
## Chapter 6 from the Alex DeCaria textbook: 'File I/O'

The Environmental Sciences are considered to be 'data' intensive as there are a number of different sources such as model output or observations. Sometimes this data types are in non-compressed file formats such as text or csv-formatted files. Sometimes data is stored in a compressed file format such as Hierarchical Data Format version 5 (HDF5) or Network Common Data Form (netCDF). This lecture will primarily focus on basic file formats (i.e non-compressed files).  
- Here will focus on opening and closing files
- Reading in and outputting data in a text-like format
- Listing files with the os.path module

**Before starting:** Make sure that you open up a Jupyter notebook session using OnDemand so you can interactively follow along with today's lecture! 

<br><br>
---
---

# Opening and closing files

**Opening files:** Files can be simply opened using Python's `open()` function, which uses the following syntax:

    my_file = 'file.txt'
    
    f = open(my_file, <mode here>)
    

The arguments for our function include the file name, which we want to read in (this should be a 'string'), and an argument for mode that refers to how we want to open up our file. The variable `f` will contain a reference to the resulting file object. Listed below are the available modes for accessing a file:

>- `r`: Text file is opened as read only
>- `w`: Text file is open as write only. Any new output will overwrite the exist file.
>- `r+` or `w+`: Text file is opened for reading and writing. Any new output will overwrite the exist file.
>- `a`: Text file is opened for writing in an appended mode. Any new changes to the file will be appended at the end.
>- `b`: This tell Python to open the file as a binary file. For exampe, `rb` indicates a read-only binary file, and `rb+` would indicate a read and write enabled binary. For the purpose of this class, you will not be using this option as much...

**Closing files:** A file will be closed using the `close()` method. This can be accomplished by *appending* the method to the file object.

    f.close()
    
If you are lazy, you can use Python's `with` construct to access the file, and do whatever with the contents of the file using the following shorthand syntax:

    with open(my_file, <mode here>) as f:
        [Do stuff to file in this Python code block]
        



<br><br>
---
---

# Reading in text from files

There are two types of loops used by Python. This includes `for` and `while` loops.

`for` loops always require an iterable object and has a similar syntax as a conditional statement. 

    for var in iterable object:
        do stuff in
        this line for 
        each iteration 
        that we are 
        looping through
        
    #end of for loop
        

In this syntax *iterable object* represents an iterable object that is being loop through, while  *var* hold the value of the 
current value of the iterable object. The python code block within the `for` loop will be performed for each iteration being performed. 
The number of iterations will be equal to the number of elements within the iterable object. 

Lets look at an example:

    temp = [36,38,40,44,48,53,60,62,64,65,65,63,60,55,50] 

    for T in temp:
        print(T)
        
    >> 36
    >> 38
    >> 40
    >> 44
    .......
    >> 50
        
When we run this block of code, Python iterate through each element within our object 'temp'. In this loop we have told Python to run the print statement for each iterable element (T) in temperature. 

<br><br>
You can also can also use a prefined range object as a iterable object. 

    for c in range(0,10):
       print('Counting.... '+str(c))
    
    >> Counting.... 0
    >> Counting.... 1
    >> Counting.... 2
    ....
    >> Counting.... 10

<br><br>
Sometimes, it isuseful to keep track of which iteration we are working on when looping through a variable using the `enumerate` command. Personally, I use this in most of my Python code, especially when I am trouble shooting bugs! For example, there may be a specific iteration where my code breaks, so its always useful to know where this happens!


    temperature = [36,38,40,44,48,53,60,62,64,65,65,63,60,55,50] 
    
    for t, temp in enumerate(temperature):
        print(t,temp)
        
    >> 0 36
    >> 1 38
    >> 2 40
    ...
    >> 14 50
    

<br><br>
---
---

`while` loops are the other looping construct used within Python. This loop runs for as a long as a specific criteria is being met.

    while condition is being met:
        execute this code block
        
    #end while loop
    
For example:
 
    a = 0
    while a < 5:
        print(a)
        a = a + 1
        
    >> 0
    >> 1 
    >> 2
    >> 3
    >> 4
 
This block of code will loop through the above code block until the condition a < 5 is met.

❗❗ Becareful when working with `while` loops as its not difficult to accidently create a loop that runs infinitely! I often refer to this as 'hanging' code, which is common problem, especally with Fortran, which also uses while constructs.

<br><br>
---
---

# Other flow constrol constructs

Sometimes we may want to control a loop if a specific criteria is met within a loop. This often requires combining conditional and looping constructs.

For example, we may want to prematurely end an iteration within a loop if a spefific criteria is met:

    temperature = [60,61,61,58,55,50,44,37,30,28,26,25]
    
    for t,temp in enumerate(temperature):
        if 50 > temp > 30:
            continue
        print(t,temp)
 
    >> 0 60
    >> 1 61
    >> 2 61
    >> 3 58
    >> 4 55
    >> 5 50
    >> 8 30
    >> 9 28
    >> 10 26
    >> 11 25
 
Here, we loop through each element in temperature. For cases where the temperature is less than 50 but greater than 30, the `if` statement condition is triggered. For elements where the `conditional` is met, the `continue` statement within our conditional statement is executed, which tells Python to ignore the lines after the `continue` statement for the iteration we are working on. 


The `break` loop control statement can be used to  prematurelyexit a loop:


    temperature = [60,61,61,58,55,50,44,37,30,28,26,25]
    
    for temp in temperature:
        if 50 > temp > 30:
            break
        print(temp)
    print('Broke out of loop')
 
    >> 60
    >> 61
    >> 61
    >> 58
    >> 55
    >> 50
    >> Broke out of loop

 
The `break` command can be used in conjunction with `for` and `while` loops

    
<br><br>
---
---
    

> # Want more practice!?<br>
> Check out the following webpages:<br>
> http://www.johnny-lin.com/pyintro/ed01/free_pdfs/ch05.pdf<br>
> https://www.tutorialspoint.com/python3/python_files_io.htm<br>
> https://www.w3schools.com/python/python_file_handling.asp<br>
> https://www.w3schools.com/python/python_file_write.asp<br>
> https://www.w3schools.com/python/python_file_remove.asp<br>



