<img src='./images/class_logo.png' width=500px align='right' style='padding-left:30px'>

**Week of October 12th, 2020**<br>  
**ATMOS 5340: Environmental Programming and Statistics**<br>
**John Horel and Derek Mallia**<br>
<br>

> # Announcement: 
> Your 5th programming assignment on Panda, Numpy Arrays, and plotting is **due in two weeks.**

> # Today's Objective
> Introduce Python's Pandas library
> Discuss why we would want to use Pandas
> Reading in data with Pandas
> Use Pandas to manipulate some basic data sets
<br><br>


#  Python Pandas

Pandas is a data manipulation tool built on Python's Numpy module. Pandas introduces two new data type structures. The first data structure type is a Pandas *series*, which is a one dimensional array. The second data structure is a *'dataframe'*, which is similar to a 2-D NumPy array, except that it can hold multiple data types within it (strings, floats, integers, datetime objects, ect...). This features make Pandas particularly good for working with time series data. In addition, I've always found reading in text and csv data rather annoying in Python, but Pandas makes this task MUCH easier! For today, we will: 
- Read csv-formatted data into Python 
- Learn how to subset and slice dataframes 
- Aggegrate and group data
- Work with time objects in Pandas
- While not discussed here, plotting data from a Pandas dataframe is super easy! (We will learn about Python plotting next week)

**Before starting:** Make sure that you open up a Jupyter notebook session using OnDemand so you can interactively follow along with today's lecture!

    
<br><br>
---
---

#  Reading in data

As a starting point, lets load the appriopriate libraries for working with Pandas:

    import numpy as np
    import pandas as pd


For the purpose of this class, we will mostly be working with *dataframes* as we will mostly be working with 2D data sets. As a first step, lets fire up a linux session on a seperate browser tab, and copy the following file into your working directory. For todays lecture, it may be a good idea to create a directory called `module7_lecture` and then `cd` into it.

    mkdir module7_lecture
    cd module7_lecture
    cp /uufs/chpc.utah.edu/common/home/u0703457/public_html/dereks_homepage/Atmos_5340/class_files/module7_zoo.csv .


Now, lets return to our Jupyter notebook session. <br>
<br>
To read in a csv file, we will be using the `pd.read.csv()` function, which is similar to Python's default csv function, except that it is a bit less cumbersome to use! This function has a number of arguments that will allow this code to deal all sorts of csv files. For this lecture, we will just focus on a few key arguments:

>- `filepath_or_buffer`: name of file we are reading in
>- `sep`: how are values seperated in our csv file
>- `header`: Do we want to include our header? If left as blank, column names are assigned from the first row of our csv file.
>- `skiprows`: How many rows do we want to skip when reading in our file? (0-base index).

<br><br>
Other arguments for this function can be found here: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html
<br><br>
Lets read in our file now:

    my_zoo = pd.read_csv('module7_zoo.csv', delimiter = ',')
   
    print(my_zoo)
    >> animal  uniq_id  water_need
    >> 0   elephant     1001         500
    >> 1   elephant     1002         600
    >> 2   elephant     1003         550
    >> 3      tiger     1004         300
    ....
    >> 20  kangaroo     1021         430
    >> 21  kangaroo     1022         410
    
    
    type(my_zoo)
    >> <class 'pandas.core.frame.DataFrame'>
    
    
And thats it.... Read in data with Pandas is usually that easy! As seen in our print statement, we are working with a Pandas data frame, where the indices on the left are the index numbers of our 2D array, while the column names are defined using the column names from the first row of our csv file.
    
<br><br>
---
---

#  Selecting rows and columns

Selecting a specific row or column within a Pandas dataframe is fairly simple. To index a column, we just use the dataframe variable name, and subset the columns by using the name of the column that we would like to select:

    print(my_zoo['animal'])
    
    >> 0     elephant
    >> 1     elephant
    >> 2     elephant
    >> 3        tiger
    ....
    >> 20    kangaroo
    >> 21    kangaroo
    >> Name: animal, dtype: object
    
<br><br>   
To get the first 5 rows of our dataframe, we can slice our data frame with the following command:

    print(my_zoo[:3])
    
    >> animal  uniq_id  water_need
    >> 0  elephant     1001         500
    >> 1  elephant     1002         600
    >> 2  elephant     1003         550
    
<br><br>  
We can also combine both commands to subset our data from the first 3 rows of the 'animal' column:

    print(my_zoo[:3]['animal'])
    
    >> 0    elephant
    >> 1    elephant
    >> 2    elephant
    >> Name: animal, dtype: object
    
<br><br>    
You also have the ability to select multiple columns by simply inserting a list of column names as part of the subset command:

    print(my_zoo[['animal','uniq_id']])
    
    >> animal  uniq_id
    >> 0   elephant     1001
    >> 1   elephant     1002
    >> 2   elephant     1003
    ....
    >> 20  kangaroo     1021
    >> 21  kangaroo     1022

How would we subset our dataframe 'my_zoo' for the last 10 rows of the animal and water_need columns?
<br><br>  


<br><br>
---
---

#  Aggregating data

Pandas dataframe structure makes it super easy to aggregate and manipulate data. For example, lets say we wanted to take an average of the water need for each animal type? We could this manually with this relatively short dataframe, but what if you needed to do this for a much larger zoo, with thousands of animals?!
Fortunately, this can be easily done in Python:

    avg_water = my_zoo.groupby('animal')['water_need'].agg(np.mean)
    
    print(avg_water)
    
    >> animal
    >> elephant    550.000000
    >> kangaroo    416.666667
    >> lion        477.500000
    >> tiger       310.000000
    >> zebra       184.285714
    >> Name: water_need, dtype: float64

<br><br>
We can also compute a bunch of other mathematical functions, simultaneously, in a single line!


    water_stats = my_zoo.groupby('animal')['water_need'].agg([np.mean,np.median,np.std,np.max,np.min])

    print(water_stats)
    
    >>            mean  median        std  amax  amin
    >> animal                                             
    >> elephant  550.000000     550  50.000000   600   500
    >> kangaroo  416.666667     410  11.547005   430   410
    >> lion      477.500000     460  93.941471   600   390
    >> tiger     310.000000     310  15.811388   330   290
    >> zebra     184.285714     220  65.791880   240    80


<br><br>
---
---

> # Want more practice!?<br>
> Check out the following webpages:<br>
> https://pandas.pydata.org/pandas-docs/version/0.15/tutorials.html<br>
> https://www.youtube.com/watch?v=dcqPhpY7tWk&t=113s<br>



